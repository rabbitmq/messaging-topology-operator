// Code generated by counterfeiter. DO NOT EDIT.
package internalfakes

import (
	"net/http"
	"sync"

	rabbithole "github.com/michaelklishin/rabbit-hole/v2"
	"github.com/rabbitmq/messaging-topology-operator/internal"
)

type FakeRabbitMQClient struct {
	ClearPermissionsInStub        func(string, string) (*http.Response, error)
	clearPermissionsInMutex       sync.RWMutex
	clearPermissionsInArgsForCall []struct {
		arg1 string
		arg2 string
	}
	clearPermissionsInReturns struct {
		result1 *http.Response
		result2 error
	}
	clearPermissionsInReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeclareBindingStub        func(string, rabbithole.BindingInfo) (*http.Response, error)
	declareBindingMutex       sync.RWMutex
	declareBindingArgsForCall []struct {
		arg1 string
		arg2 rabbithole.BindingInfo
	}
	declareBindingReturns struct {
		result1 *http.Response
		result2 error
	}
	declareBindingReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeclareExchangeStub        func(string, string, rabbithole.ExchangeSettings) (*http.Response, error)
	declareExchangeMutex       sync.RWMutex
	declareExchangeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.ExchangeSettings
	}
	declareExchangeReturns struct {
		result1 *http.Response
		result2 error
	}
	declareExchangeReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeclareQueueStub        func(string, string, rabbithole.QueueSettings) (*http.Response, error)
	declareQueueMutex       sync.RWMutex
	declareQueueArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.QueueSettings
	}
	declareQueueReturns struct {
		result1 *http.Response
		result2 error
	}
	declareQueueReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeclareShovelStub        func(string, string, rabbithole.ShovelDefinition) (*http.Response, error)
	declareShovelMutex       sync.RWMutex
	declareShovelArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.ShovelDefinition
	}
	declareShovelReturns struct {
		result1 *http.Response
		result2 error
	}
	declareShovelReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteBindingStub        func(string, rabbithole.BindingInfo) (*http.Response, error)
	deleteBindingMutex       sync.RWMutex
	deleteBindingArgsForCall []struct {
		arg1 string
		arg2 rabbithole.BindingInfo
	}
	deleteBindingReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteBindingReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteExchangeStub        func(string, string) (*http.Response, error)
	deleteExchangeMutex       sync.RWMutex
	deleteExchangeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteExchangeReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteExchangeReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteFederationUpstreamStub        func(string, string) (*http.Response, error)
	deleteFederationUpstreamMutex       sync.RWMutex
	deleteFederationUpstreamArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteFederationUpstreamReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteFederationUpstreamReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteGlobalParameterStub        func(string) (*http.Response, error)
	deleteGlobalParameterMutex       sync.RWMutex
	deleteGlobalParameterArgsForCall []struct {
		arg1 string
	}
	deleteGlobalParameterReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteGlobalParameterReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeletePolicyStub        func(string, string) (*http.Response, error)
	deletePolicyMutex       sync.RWMutex
	deletePolicyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deletePolicyReturns struct {
		result1 *http.Response
		result2 error
	}
	deletePolicyReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteQueueStub        func(string, string, ...rabbithole.QueueDeleteOptions) (*http.Response, error)
	deleteQueueMutex       sync.RWMutex
	deleteQueueArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []rabbithole.QueueDeleteOptions
	}
	deleteQueueReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteQueueReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteShovelStub        func(string, string) (*http.Response, error)
	deleteShovelMutex       sync.RWMutex
	deleteShovelArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteShovelReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteShovelReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteUserStub        func(string) (*http.Response, error)
	deleteUserMutex       sync.RWMutex
	deleteUserArgsForCall []struct {
		arg1 string
	}
	deleteUserReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteUserReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteVhostStub        func(string) (*http.Response, error)
	deleteVhostMutex       sync.RWMutex
	deleteVhostArgsForCall []struct {
		arg1 string
	}
	deleteVhostReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteVhostReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	ListExchangeBindingsBetweenStub        func(string, string, string) ([]rabbithole.BindingInfo, error)
	listExchangeBindingsBetweenMutex       sync.RWMutex
	listExchangeBindingsBetweenArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	listExchangeBindingsBetweenReturns struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}
	listExchangeBindingsBetweenReturnsOnCall map[int]struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}
	ListQueueBindingsBetweenStub        func(string, string, string) ([]rabbithole.BindingInfo, error)
	listQueueBindingsBetweenMutex       sync.RWMutex
	listQueueBindingsBetweenArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	listQueueBindingsBetweenReturns struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}
	listQueueBindingsBetweenReturnsOnCall map[int]struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}
	PutFederationUpstreamStub        func(string, string, rabbithole.FederationDefinition) (*http.Response, error)
	putFederationUpstreamMutex       sync.RWMutex
	putFederationUpstreamArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.FederationDefinition
	}
	putFederationUpstreamReturns struct {
		result1 *http.Response
		result2 error
	}
	putFederationUpstreamReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutGlobalParameterStub        func(string, interface{}) (*http.Response, error)
	putGlobalParameterMutex       sync.RWMutex
	putGlobalParameterArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	putGlobalParameterReturns struct {
		result1 *http.Response
		result2 error
	}
	putGlobalParameterReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutPolicyStub        func(string, string, rabbithole.Policy) (*http.Response, error)
	putPolicyMutex       sync.RWMutex
	putPolicyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.Policy
	}
	putPolicyReturns struct {
		result1 *http.Response
		result2 error
	}
	putPolicyReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutUserStub        func(string, rabbithole.UserSettings) (*http.Response, error)
	putUserMutex       sync.RWMutex
	putUserArgsForCall []struct {
		arg1 string
		arg2 rabbithole.UserSettings
	}
	putUserReturns struct {
		result1 *http.Response
		result2 error
	}
	putUserReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	PutVhostStub        func(string, rabbithole.VhostSettings) (*http.Response, error)
	putVhostMutex       sync.RWMutex
	putVhostArgsForCall []struct {
		arg1 string
		arg2 rabbithole.VhostSettings
	}
	putVhostReturns struct {
		result1 *http.Response
		result2 error
	}
	putVhostReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	UpdatePermissionsInStub        func(string, string, rabbithole.Permissions) (*http.Response, error)
	updatePermissionsInMutex       sync.RWMutex
	updatePermissionsInArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 rabbithole.Permissions
	}
	updatePermissionsInReturns struct {
		result1 *http.Response
		result2 error
	}
	updatePermissionsInReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRabbitMQClient) ClearPermissionsIn(arg1 string, arg2 string) (*http.Response, error) {
	fake.clearPermissionsInMutex.Lock()
	ret, specificReturn := fake.clearPermissionsInReturnsOnCall[len(fake.clearPermissionsInArgsForCall)]
	fake.clearPermissionsInArgsForCall = append(fake.clearPermissionsInArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ClearPermissionsInStub
	fakeReturns := fake.clearPermissionsInReturns
	fake.recordInvocation("ClearPermissionsIn", []interface{}{arg1, arg2})
	fake.clearPermissionsInMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) ClearPermissionsInCallCount() int {
	fake.clearPermissionsInMutex.RLock()
	defer fake.clearPermissionsInMutex.RUnlock()
	return len(fake.clearPermissionsInArgsForCall)
}

func (fake *FakeRabbitMQClient) ClearPermissionsInCalls(stub func(string, string) (*http.Response, error)) {
	fake.clearPermissionsInMutex.Lock()
	defer fake.clearPermissionsInMutex.Unlock()
	fake.ClearPermissionsInStub = stub
}

func (fake *FakeRabbitMQClient) ClearPermissionsInArgsForCall(i int) (string, string) {
	fake.clearPermissionsInMutex.RLock()
	defer fake.clearPermissionsInMutex.RUnlock()
	argsForCall := fake.clearPermissionsInArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) ClearPermissionsInReturns(result1 *http.Response, result2 error) {
	fake.clearPermissionsInMutex.Lock()
	defer fake.clearPermissionsInMutex.Unlock()
	fake.ClearPermissionsInStub = nil
	fake.clearPermissionsInReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) ClearPermissionsInReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.clearPermissionsInMutex.Lock()
	defer fake.clearPermissionsInMutex.Unlock()
	fake.ClearPermissionsInStub = nil
	if fake.clearPermissionsInReturnsOnCall == nil {
		fake.clearPermissionsInReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.clearPermissionsInReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareBinding(arg1 string, arg2 rabbithole.BindingInfo) (*http.Response, error) {
	fake.declareBindingMutex.Lock()
	ret, specificReturn := fake.declareBindingReturnsOnCall[len(fake.declareBindingArgsForCall)]
	fake.declareBindingArgsForCall = append(fake.declareBindingArgsForCall, struct {
		arg1 string
		arg2 rabbithole.BindingInfo
	}{arg1, arg2})
	stub := fake.DeclareBindingStub
	fakeReturns := fake.declareBindingReturns
	fake.recordInvocation("DeclareBinding", []interface{}{arg1, arg2})
	fake.declareBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeclareBindingCallCount() int {
	fake.declareBindingMutex.RLock()
	defer fake.declareBindingMutex.RUnlock()
	return len(fake.declareBindingArgsForCall)
}

func (fake *FakeRabbitMQClient) DeclareBindingCalls(stub func(string, rabbithole.BindingInfo) (*http.Response, error)) {
	fake.declareBindingMutex.Lock()
	defer fake.declareBindingMutex.Unlock()
	fake.DeclareBindingStub = stub
}

func (fake *FakeRabbitMQClient) DeclareBindingArgsForCall(i int) (string, rabbithole.BindingInfo) {
	fake.declareBindingMutex.RLock()
	defer fake.declareBindingMutex.RUnlock()
	argsForCall := fake.declareBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeclareBindingReturns(result1 *http.Response, result2 error) {
	fake.declareBindingMutex.Lock()
	defer fake.declareBindingMutex.Unlock()
	fake.DeclareBindingStub = nil
	fake.declareBindingReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareBindingReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.declareBindingMutex.Lock()
	defer fake.declareBindingMutex.Unlock()
	fake.DeclareBindingStub = nil
	if fake.declareBindingReturnsOnCall == nil {
		fake.declareBindingReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.declareBindingReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareExchange(arg1 string, arg2 string, arg3 rabbithole.ExchangeSettings) (*http.Response, error) {
	fake.declareExchangeMutex.Lock()
	ret, specificReturn := fake.declareExchangeReturnsOnCall[len(fake.declareExchangeArgsForCall)]
	fake.declareExchangeArgsForCall = append(fake.declareExchangeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.ExchangeSettings
	}{arg1, arg2, arg3})
	stub := fake.DeclareExchangeStub
	fakeReturns := fake.declareExchangeReturns
	fake.recordInvocation("DeclareExchange", []interface{}{arg1, arg2, arg3})
	fake.declareExchangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeclareExchangeCallCount() int {
	fake.declareExchangeMutex.RLock()
	defer fake.declareExchangeMutex.RUnlock()
	return len(fake.declareExchangeArgsForCall)
}

func (fake *FakeRabbitMQClient) DeclareExchangeCalls(stub func(string, string, rabbithole.ExchangeSettings) (*http.Response, error)) {
	fake.declareExchangeMutex.Lock()
	defer fake.declareExchangeMutex.Unlock()
	fake.DeclareExchangeStub = stub
}

func (fake *FakeRabbitMQClient) DeclareExchangeArgsForCall(i int) (string, string, rabbithole.ExchangeSettings) {
	fake.declareExchangeMutex.RLock()
	defer fake.declareExchangeMutex.RUnlock()
	argsForCall := fake.declareExchangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) DeclareExchangeReturns(result1 *http.Response, result2 error) {
	fake.declareExchangeMutex.Lock()
	defer fake.declareExchangeMutex.Unlock()
	fake.DeclareExchangeStub = nil
	fake.declareExchangeReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareExchangeReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.declareExchangeMutex.Lock()
	defer fake.declareExchangeMutex.Unlock()
	fake.DeclareExchangeStub = nil
	if fake.declareExchangeReturnsOnCall == nil {
		fake.declareExchangeReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.declareExchangeReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareQueue(arg1 string, arg2 string, arg3 rabbithole.QueueSettings) (*http.Response, error) {
	fake.declareQueueMutex.Lock()
	ret, specificReturn := fake.declareQueueReturnsOnCall[len(fake.declareQueueArgsForCall)]
	fake.declareQueueArgsForCall = append(fake.declareQueueArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.QueueSettings
	}{arg1, arg2, arg3})
	stub := fake.DeclareQueueStub
	fakeReturns := fake.declareQueueReturns
	fake.recordInvocation("DeclareQueue", []interface{}{arg1, arg2, arg3})
	fake.declareQueueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeclareQueueCallCount() int {
	fake.declareQueueMutex.RLock()
	defer fake.declareQueueMutex.RUnlock()
	return len(fake.declareQueueArgsForCall)
}

func (fake *FakeRabbitMQClient) DeclareQueueCalls(stub func(string, string, rabbithole.QueueSettings) (*http.Response, error)) {
	fake.declareQueueMutex.Lock()
	defer fake.declareQueueMutex.Unlock()
	fake.DeclareQueueStub = stub
}

func (fake *FakeRabbitMQClient) DeclareQueueArgsForCall(i int) (string, string, rabbithole.QueueSettings) {
	fake.declareQueueMutex.RLock()
	defer fake.declareQueueMutex.RUnlock()
	argsForCall := fake.declareQueueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) DeclareQueueReturns(result1 *http.Response, result2 error) {
	fake.declareQueueMutex.Lock()
	defer fake.declareQueueMutex.Unlock()
	fake.DeclareQueueStub = nil
	fake.declareQueueReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareQueueReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.declareQueueMutex.Lock()
	defer fake.declareQueueMutex.Unlock()
	fake.DeclareQueueStub = nil
	if fake.declareQueueReturnsOnCall == nil {
		fake.declareQueueReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.declareQueueReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareShovel(arg1 string, arg2 string, arg3 rabbithole.ShovelDefinition) (*http.Response, error) {
	fake.declareShovelMutex.Lock()
	ret, specificReturn := fake.declareShovelReturnsOnCall[len(fake.declareShovelArgsForCall)]
	fake.declareShovelArgsForCall = append(fake.declareShovelArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.ShovelDefinition
	}{arg1, arg2, arg3})
	stub := fake.DeclareShovelStub
	fakeReturns := fake.declareShovelReturns
	fake.recordInvocation("DeclareShovel", []interface{}{arg1, arg2, arg3})
	fake.declareShovelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeclareShovelCallCount() int {
	fake.declareShovelMutex.RLock()
	defer fake.declareShovelMutex.RUnlock()
	return len(fake.declareShovelArgsForCall)
}

func (fake *FakeRabbitMQClient) DeclareShovelCalls(stub func(string, string, rabbithole.ShovelDefinition) (*http.Response, error)) {
	fake.declareShovelMutex.Lock()
	defer fake.declareShovelMutex.Unlock()
	fake.DeclareShovelStub = stub
}

func (fake *FakeRabbitMQClient) DeclareShovelArgsForCall(i int) (string, string, rabbithole.ShovelDefinition) {
	fake.declareShovelMutex.RLock()
	defer fake.declareShovelMutex.RUnlock()
	argsForCall := fake.declareShovelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) DeclareShovelReturns(result1 *http.Response, result2 error) {
	fake.declareShovelMutex.Lock()
	defer fake.declareShovelMutex.Unlock()
	fake.DeclareShovelStub = nil
	fake.declareShovelReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeclareShovelReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.declareShovelMutex.Lock()
	defer fake.declareShovelMutex.Unlock()
	fake.DeclareShovelStub = nil
	if fake.declareShovelReturnsOnCall == nil {
		fake.declareShovelReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.declareShovelReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteBinding(arg1 string, arg2 rabbithole.BindingInfo) (*http.Response, error) {
	fake.deleteBindingMutex.Lock()
	ret, specificReturn := fake.deleteBindingReturnsOnCall[len(fake.deleteBindingArgsForCall)]
	fake.deleteBindingArgsForCall = append(fake.deleteBindingArgsForCall, struct {
		arg1 string
		arg2 rabbithole.BindingInfo
	}{arg1, arg2})
	stub := fake.DeleteBindingStub
	fakeReturns := fake.deleteBindingReturns
	fake.recordInvocation("DeleteBinding", []interface{}{arg1, arg2})
	fake.deleteBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteBindingCallCount() int {
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	return len(fake.deleteBindingArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteBindingCalls(stub func(string, rabbithole.BindingInfo) (*http.Response, error)) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = stub
}

func (fake *FakeRabbitMQClient) DeleteBindingArgsForCall(i int) (string, rabbithole.BindingInfo) {
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	argsForCall := fake.deleteBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeleteBindingReturns(result1 *http.Response, result2 error) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = nil
	fake.deleteBindingReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteBindingReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = nil
	if fake.deleteBindingReturnsOnCall == nil {
		fake.deleteBindingReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteBindingReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteExchange(arg1 string, arg2 string) (*http.Response, error) {
	fake.deleteExchangeMutex.Lock()
	ret, specificReturn := fake.deleteExchangeReturnsOnCall[len(fake.deleteExchangeArgsForCall)]
	fake.deleteExchangeArgsForCall = append(fake.deleteExchangeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteExchangeStub
	fakeReturns := fake.deleteExchangeReturns
	fake.recordInvocation("DeleteExchange", []interface{}{arg1, arg2})
	fake.deleteExchangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteExchangeCallCount() int {
	fake.deleteExchangeMutex.RLock()
	defer fake.deleteExchangeMutex.RUnlock()
	return len(fake.deleteExchangeArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteExchangeCalls(stub func(string, string) (*http.Response, error)) {
	fake.deleteExchangeMutex.Lock()
	defer fake.deleteExchangeMutex.Unlock()
	fake.DeleteExchangeStub = stub
}

func (fake *FakeRabbitMQClient) DeleteExchangeArgsForCall(i int) (string, string) {
	fake.deleteExchangeMutex.RLock()
	defer fake.deleteExchangeMutex.RUnlock()
	argsForCall := fake.deleteExchangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeleteExchangeReturns(result1 *http.Response, result2 error) {
	fake.deleteExchangeMutex.Lock()
	defer fake.deleteExchangeMutex.Unlock()
	fake.DeleteExchangeStub = nil
	fake.deleteExchangeReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteExchangeReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteExchangeMutex.Lock()
	defer fake.deleteExchangeMutex.Unlock()
	fake.DeleteExchangeStub = nil
	if fake.deleteExchangeReturnsOnCall == nil {
		fake.deleteExchangeReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteExchangeReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstream(arg1 string, arg2 string) (*http.Response, error) {
	fake.deleteFederationUpstreamMutex.Lock()
	ret, specificReturn := fake.deleteFederationUpstreamReturnsOnCall[len(fake.deleteFederationUpstreamArgsForCall)]
	fake.deleteFederationUpstreamArgsForCall = append(fake.deleteFederationUpstreamArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteFederationUpstreamStub
	fakeReturns := fake.deleteFederationUpstreamReturns
	fake.recordInvocation("DeleteFederationUpstream", []interface{}{arg1, arg2})
	fake.deleteFederationUpstreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstreamCallCount() int {
	fake.deleteFederationUpstreamMutex.RLock()
	defer fake.deleteFederationUpstreamMutex.RUnlock()
	return len(fake.deleteFederationUpstreamArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstreamCalls(stub func(string, string) (*http.Response, error)) {
	fake.deleteFederationUpstreamMutex.Lock()
	defer fake.deleteFederationUpstreamMutex.Unlock()
	fake.DeleteFederationUpstreamStub = stub
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstreamArgsForCall(i int) (string, string) {
	fake.deleteFederationUpstreamMutex.RLock()
	defer fake.deleteFederationUpstreamMutex.RUnlock()
	argsForCall := fake.deleteFederationUpstreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstreamReturns(result1 *http.Response, result2 error) {
	fake.deleteFederationUpstreamMutex.Lock()
	defer fake.deleteFederationUpstreamMutex.Unlock()
	fake.DeleteFederationUpstreamStub = nil
	fake.deleteFederationUpstreamReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteFederationUpstreamReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteFederationUpstreamMutex.Lock()
	defer fake.deleteFederationUpstreamMutex.Unlock()
	fake.DeleteFederationUpstreamStub = nil
	if fake.deleteFederationUpstreamReturnsOnCall == nil {
		fake.deleteFederationUpstreamReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteFederationUpstreamReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameter(arg1 string) (*http.Response, error) {
	fake.deleteGlobalParameterMutex.Lock()
	ret, specificReturn := fake.deleteGlobalParameterReturnsOnCall[len(fake.deleteGlobalParameterArgsForCall)]
	fake.deleteGlobalParameterArgsForCall = append(fake.deleteGlobalParameterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteGlobalParameterStub
	fakeReturns := fake.deleteGlobalParameterReturns
	fake.recordInvocation("DeleteGlobalParameter", []interface{}{arg1})
	fake.deleteGlobalParameterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameterCallCount() int {
	fake.deleteGlobalParameterMutex.RLock()
	defer fake.deleteGlobalParameterMutex.RUnlock()
	return len(fake.deleteGlobalParameterArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameterCalls(stub func(string) (*http.Response, error)) {
	fake.deleteGlobalParameterMutex.Lock()
	defer fake.deleteGlobalParameterMutex.Unlock()
	fake.DeleteGlobalParameterStub = stub
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameterArgsForCall(i int) string {
	fake.deleteGlobalParameterMutex.RLock()
	defer fake.deleteGlobalParameterMutex.RUnlock()
	argsForCall := fake.deleteGlobalParameterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameterReturns(result1 *http.Response, result2 error) {
	fake.deleteGlobalParameterMutex.Lock()
	defer fake.deleteGlobalParameterMutex.Unlock()
	fake.DeleteGlobalParameterStub = nil
	fake.deleteGlobalParameterReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteGlobalParameterReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteGlobalParameterMutex.Lock()
	defer fake.deleteGlobalParameterMutex.Unlock()
	fake.DeleteGlobalParameterStub = nil
	if fake.deleteGlobalParameterReturnsOnCall == nil {
		fake.deleteGlobalParameterReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteGlobalParameterReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeletePolicy(arg1 string, arg2 string) (*http.Response, error) {
	fake.deletePolicyMutex.Lock()
	ret, specificReturn := fake.deletePolicyReturnsOnCall[len(fake.deletePolicyArgsForCall)]
	fake.deletePolicyArgsForCall = append(fake.deletePolicyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeletePolicyStub
	fakeReturns := fake.deletePolicyReturns
	fake.recordInvocation("DeletePolicy", []interface{}{arg1, arg2})
	fake.deletePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeletePolicyCallCount() int {
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	return len(fake.deletePolicyArgsForCall)
}

func (fake *FakeRabbitMQClient) DeletePolicyCalls(stub func(string, string) (*http.Response, error)) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = stub
}

func (fake *FakeRabbitMQClient) DeletePolicyArgsForCall(i int) (string, string) {
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	argsForCall := fake.deletePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeletePolicyReturns(result1 *http.Response, result2 error) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = nil
	fake.deletePolicyReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeletePolicyReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = nil
	if fake.deletePolicyReturnsOnCall == nil {
		fake.deletePolicyReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deletePolicyReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteQueue(arg1 string, arg2 string, arg3 ...rabbithole.QueueDeleteOptions) (*http.Response, error) {
	fake.deleteQueueMutex.Lock()
	ret, specificReturn := fake.deleteQueueReturnsOnCall[len(fake.deleteQueueArgsForCall)]
	fake.deleteQueueArgsForCall = append(fake.deleteQueueArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []rabbithole.QueueDeleteOptions
	}{arg1, arg2, arg3})
	stub := fake.DeleteQueueStub
	fakeReturns := fake.deleteQueueReturns
	fake.recordInvocation("DeleteQueue", []interface{}{arg1, arg2, arg3})
	fake.deleteQueueMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteQueueCallCount() int {
	fake.deleteQueueMutex.RLock()
	defer fake.deleteQueueMutex.RUnlock()
	return len(fake.deleteQueueArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteQueueCalls(stub func(string, string, ...rabbithole.QueueDeleteOptions) (*http.Response, error)) {
	fake.deleteQueueMutex.Lock()
	defer fake.deleteQueueMutex.Unlock()
	fake.DeleteQueueStub = stub
}

func (fake *FakeRabbitMQClient) DeleteQueueArgsForCall(i int) (string, string, []rabbithole.QueueDeleteOptions) {
	fake.deleteQueueMutex.RLock()
	defer fake.deleteQueueMutex.RUnlock()
	argsForCall := fake.deleteQueueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) DeleteQueueReturns(result1 *http.Response, result2 error) {
	fake.deleteQueueMutex.Lock()
	defer fake.deleteQueueMutex.Unlock()
	fake.DeleteQueueStub = nil
	fake.deleteQueueReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteQueueReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteQueueMutex.Lock()
	defer fake.deleteQueueMutex.Unlock()
	fake.DeleteQueueStub = nil
	if fake.deleteQueueReturnsOnCall == nil {
		fake.deleteQueueReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteQueueReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteShovel(arg1 string, arg2 string) (*http.Response, error) {
	fake.deleteShovelMutex.Lock()
	ret, specificReturn := fake.deleteShovelReturnsOnCall[len(fake.deleteShovelArgsForCall)]
	fake.deleteShovelArgsForCall = append(fake.deleteShovelArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteShovelStub
	fakeReturns := fake.deleteShovelReturns
	fake.recordInvocation("DeleteShovel", []interface{}{arg1, arg2})
	fake.deleteShovelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteShovelCallCount() int {
	fake.deleteShovelMutex.RLock()
	defer fake.deleteShovelMutex.RUnlock()
	return len(fake.deleteShovelArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteShovelCalls(stub func(string, string) (*http.Response, error)) {
	fake.deleteShovelMutex.Lock()
	defer fake.deleteShovelMutex.Unlock()
	fake.DeleteShovelStub = stub
}

func (fake *FakeRabbitMQClient) DeleteShovelArgsForCall(i int) (string, string) {
	fake.deleteShovelMutex.RLock()
	defer fake.deleteShovelMutex.RUnlock()
	argsForCall := fake.deleteShovelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) DeleteShovelReturns(result1 *http.Response, result2 error) {
	fake.deleteShovelMutex.Lock()
	defer fake.deleteShovelMutex.Unlock()
	fake.DeleteShovelStub = nil
	fake.deleteShovelReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteShovelReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteShovelMutex.Lock()
	defer fake.deleteShovelMutex.Unlock()
	fake.DeleteShovelStub = nil
	if fake.deleteShovelReturnsOnCall == nil {
		fake.deleteShovelReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteShovelReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteUser(arg1 string) (*http.Response, error) {
	fake.deleteUserMutex.Lock()
	ret, specificReturn := fake.deleteUserReturnsOnCall[len(fake.deleteUserArgsForCall)]
	fake.deleteUserArgsForCall = append(fake.deleteUserArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteUserStub
	fakeReturns := fake.deleteUserReturns
	fake.recordInvocation("DeleteUser", []interface{}{arg1})
	fake.deleteUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteUserCallCount() int {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	return len(fake.deleteUserArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteUserCalls(stub func(string) (*http.Response, error)) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = stub
}

func (fake *FakeRabbitMQClient) DeleteUserArgsForCall(i int) string {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	argsForCall := fake.deleteUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRabbitMQClient) DeleteUserReturns(result1 *http.Response, result2 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	fake.deleteUserReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteUserReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	if fake.deleteUserReturnsOnCall == nil {
		fake.deleteUserReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteUserReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteVhost(arg1 string) (*http.Response, error) {
	fake.deleteVhostMutex.Lock()
	ret, specificReturn := fake.deleteVhostReturnsOnCall[len(fake.deleteVhostArgsForCall)]
	fake.deleteVhostArgsForCall = append(fake.deleteVhostArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteVhostStub
	fakeReturns := fake.deleteVhostReturns
	fake.recordInvocation("DeleteVhost", []interface{}{arg1})
	fake.deleteVhostMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) DeleteVhostCallCount() int {
	fake.deleteVhostMutex.RLock()
	defer fake.deleteVhostMutex.RUnlock()
	return len(fake.deleteVhostArgsForCall)
}

func (fake *FakeRabbitMQClient) DeleteVhostCalls(stub func(string) (*http.Response, error)) {
	fake.deleteVhostMutex.Lock()
	defer fake.deleteVhostMutex.Unlock()
	fake.DeleteVhostStub = stub
}

func (fake *FakeRabbitMQClient) DeleteVhostArgsForCall(i int) string {
	fake.deleteVhostMutex.RLock()
	defer fake.deleteVhostMutex.RUnlock()
	argsForCall := fake.deleteVhostArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRabbitMQClient) DeleteVhostReturns(result1 *http.Response, result2 error) {
	fake.deleteVhostMutex.Lock()
	defer fake.deleteVhostMutex.Unlock()
	fake.DeleteVhostStub = nil
	fake.deleteVhostReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) DeleteVhostReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteVhostMutex.Lock()
	defer fake.deleteVhostMutex.Unlock()
	fake.DeleteVhostStub = nil
	if fake.deleteVhostReturnsOnCall == nil {
		fake.deleteVhostReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteVhostReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetween(arg1 string, arg2 string, arg3 string) ([]rabbithole.BindingInfo, error) {
	fake.listExchangeBindingsBetweenMutex.Lock()
	ret, specificReturn := fake.listExchangeBindingsBetweenReturnsOnCall[len(fake.listExchangeBindingsBetweenArgsForCall)]
	fake.listExchangeBindingsBetweenArgsForCall = append(fake.listExchangeBindingsBetweenArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListExchangeBindingsBetweenStub
	fakeReturns := fake.listExchangeBindingsBetweenReturns
	fake.recordInvocation("ListExchangeBindingsBetween", []interface{}{arg1, arg2, arg3})
	fake.listExchangeBindingsBetweenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetweenCallCount() int {
	fake.listExchangeBindingsBetweenMutex.RLock()
	defer fake.listExchangeBindingsBetweenMutex.RUnlock()
	return len(fake.listExchangeBindingsBetweenArgsForCall)
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetweenCalls(stub func(string, string, string) ([]rabbithole.BindingInfo, error)) {
	fake.listExchangeBindingsBetweenMutex.Lock()
	defer fake.listExchangeBindingsBetweenMutex.Unlock()
	fake.ListExchangeBindingsBetweenStub = stub
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetweenArgsForCall(i int) (string, string, string) {
	fake.listExchangeBindingsBetweenMutex.RLock()
	defer fake.listExchangeBindingsBetweenMutex.RUnlock()
	argsForCall := fake.listExchangeBindingsBetweenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetweenReturns(result1 []rabbithole.BindingInfo, result2 error) {
	fake.listExchangeBindingsBetweenMutex.Lock()
	defer fake.listExchangeBindingsBetweenMutex.Unlock()
	fake.ListExchangeBindingsBetweenStub = nil
	fake.listExchangeBindingsBetweenReturns = struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) ListExchangeBindingsBetweenReturnsOnCall(i int, result1 []rabbithole.BindingInfo, result2 error) {
	fake.listExchangeBindingsBetweenMutex.Lock()
	defer fake.listExchangeBindingsBetweenMutex.Unlock()
	fake.ListExchangeBindingsBetweenStub = nil
	if fake.listExchangeBindingsBetweenReturnsOnCall == nil {
		fake.listExchangeBindingsBetweenReturnsOnCall = make(map[int]struct {
			result1 []rabbithole.BindingInfo
			result2 error
		})
	}
	fake.listExchangeBindingsBetweenReturnsOnCall[i] = struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetween(arg1 string, arg2 string, arg3 string) ([]rabbithole.BindingInfo, error) {
	fake.listQueueBindingsBetweenMutex.Lock()
	ret, specificReturn := fake.listQueueBindingsBetweenReturnsOnCall[len(fake.listQueueBindingsBetweenArgsForCall)]
	fake.listQueueBindingsBetweenArgsForCall = append(fake.listQueueBindingsBetweenArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListQueueBindingsBetweenStub
	fakeReturns := fake.listQueueBindingsBetweenReturns
	fake.recordInvocation("ListQueueBindingsBetween", []interface{}{arg1, arg2, arg3})
	fake.listQueueBindingsBetweenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetweenCallCount() int {
	fake.listQueueBindingsBetweenMutex.RLock()
	defer fake.listQueueBindingsBetweenMutex.RUnlock()
	return len(fake.listQueueBindingsBetweenArgsForCall)
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetweenCalls(stub func(string, string, string) ([]rabbithole.BindingInfo, error)) {
	fake.listQueueBindingsBetweenMutex.Lock()
	defer fake.listQueueBindingsBetweenMutex.Unlock()
	fake.ListQueueBindingsBetweenStub = stub
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetweenArgsForCall(i int) (string, string, string) {
	fake.listQueueBindingsBetweenMutex.RLock()
	defer fake.listQueueBindingsBetweenMutex.RUnlock()
	argsForCall := fake.listQueueBindingsBetweenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetweenReturns(result1 []rabbithole.BindingInfo, result2 error) {
	fake.listQueueBindingsBetweenMutex.Lock()
	defer fake.listQueueBindingsBetweenMutex.Unlock()
	fake.ListQueueBindingsBetweenStub = nil
	fake.listQueueBindingsBetweenReturns = struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) ListQueueBindingsBetweenReturnsOnCall(i int, result1 []rabbithole.BindingInfo, result2 error) {
	fake.listQueueBindingsBetweenMutex.Lock()
	defer fake.listQueueBindingsBetweenMutex.Unlock()
	fake.ListQueueBindingsBetweenStub = nil
	if fake.listQueueBindingsBetweenReturnsOnCall == nil {
		fake.listQueueBindingsBetweenReturnsOnCall = make(map[int]struct {
			result1 []rabbithole.BindingInfo
			result2 error
		})
	}
	fake.listQueueBindingsBetweenReturnsOnCall[i] = struct {
		result1 []rabbithole.BindingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutFederationUpstream(arg1 string, arg2 string, arg3 rabbithole.FederationDefinition) (*http.Response, error) {
	fake.putFederationUpstreamMutex.Lock()
	ret, specificReturn := fake.putFederationUpstreamReturnsOnCall[len(fake.putFederationUpstreamArgsForCall)]
	fake.putFederationUpstreamArgsForCall = append(fake.putFederationUpstreamArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.FederationDefinition
	}{arg1, arg2, arg3})
	stub := fake.PutFederationUpstreamStub
	fakeReturns := fake.putFederationUpstreamReturns
	fake.recordInvocation("PutFederationUpstream", []interface{}{arg1, arg2, arg3})
	fake.putFederationUpstreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) PutFederationUpstreamCallCount() int {
	fake.putFederationUpstreamMutex.RLock()
	defer fake.putFederationUpstreamMutex.RUnlock()
	return len(fake.putFederationUpstreamArgsForCall)
}

func (fake *FakeRabbitMQClient) PutFederationUpstreamCalls(stub func(string, string, rabbithole.FederationDefinition) (*http.Response, error)) {
	fake.putFederationUpstreamMutex.Lock()
	defer fake.putFederationUpstreamMutex.Unlock()
	fake.PutFederationUpstreamStub = stub
}

func (fake *FakeRabbitMQClient) PutFederationUpstreamArgsForCall(i int) (string, string, rabbithole.FederationDefinition) {
	fake.putFederationUpstreamMutex.RLock()
	defer fake.putFederationUpstreamMutex.RUnlock()
	argsForCall := fake.putFederationUpstreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) PutFederationUpstreamReturns(result1 *http.Response, result2 error) {
	fake.putFederationUpstreamMutex.Lock()
	defer fake.putFederationUpstreamMutex.Unlock()
	fake.PutFederationUpstreamStub = nil
	fake.putFederationUpstreamReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutFederationUpstreamReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putFederationUpstreamMutex.Lock()
	defer fake.putFederationUpstreamMutex.Unlock()
	fake.PutFederationUpstreamStub = nil
	if fake.putFederationUpstreamReturnsOnCall == nil {
		fake.putFederationUpstreamReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putFederationUpstreamReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutGlobalParameter(arg1 string, arg2 interface{}) (*http.Response, error) {
	fake.putGlobalParameterMutex.Lock()
	ret, specificReturn := fake.putGlobalParameterReturnsOnCall[len(fake.putGlobalParameterArgsForCall)]
	fake.putGlobalParameterArgsForCall = append(fake.putGlobalParameterArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.PutGlobalParameterStub
	fakeReturns := fake.putGlobalParameterReturns
	fake.recordInvocation("PutGlobalParameter", []interface{}{arg1, arg2})
	fake.putGlobalParameterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) PutGlobalParameterCallCount() int {
	fake.putGlobalParameterMutex.RLock()
	defer fake.putGlobalParameterMutex.RUnlock()
	return len(fake.putGlobalParameterArgsForCall)
}

func (fake *FakeRabbitMQClient) PutGlobalParameterCalls(stub func(string, interface{}) (*http.Response, error)) {
	fake.putGlobalParameterMutex.Lock()
	defer fake.putGlobalParameterMutex.Unlock()
	fake.PutGlobalParameterStub = stub
}

func (fake *FakeRabbitMQClient) PutGlobalParameterArgsForCall(i int) (string, interface{}) {
	fake.putGlobalParameterMutex.RLock()
	defer fake.putGlobalParameterMutex.RUnlock()
	argsForCall := fake.putGlobalParameterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) PutGlobalParameterReturns(result1 *http.Response, result2 error) {
	fake.putGlobalParameterMutex.Lock()
	defer fake.putGlobalParameterMutex.Unlock()
	fake.PutGlobalParameterStub = nil
	fake.putGlobalParameterReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutGlobalParameterReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putGlobalParameterMutex.Lock()
	defer fake.putGlobalParameterMutex.Unlock()
	fake.PutGlobalParameterStub = nil
	if fake.putGlobalParameterReturnsOnCall == nil {
		fake.putGlobalParameterReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putGlobalParameterReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutPolicy(arg1 string, arg2 string, arg3 rabbithole.Policy) (*http.Response, error) {
	fake.putPolicyMutex.Lock()
	ret, specificReturn := fake.putPolicyReturnsOnCall[len(fake.putPolicyArgsForCall)]
	fake.putPolicyArgsForCall = append(fake.putPolicyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.Policy
	}{arg1, arg2, arg3})
	stub := fake.PutPolicyStub
	fakeReturns := fake.putPolicyReturns
	fake.recordInvocation("PutPolicy", []interface{}{arg1, arg2, arg3})
	fake.putPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) PutPolicyCallCount() int {
	fake.putPolicyMutex.RLock()
	defer fake.putPolicyMutex.RUnlock()
	return len(fake.putPolicyArgsForCall)
}

func (fake *FakeRabbitMQClient) PutPolicyCalls(stub func(string, string, rabbithole.Policy) (*http.Response, error)) {
	fake.putPolicyMutex.Lock()
	defer fake.putPolicyMutex.Unlock()
	fake.PutPolicyStub = stub
}

func (fake *FakeRabbitMQClient) PutPolicyArgsForCall(i int) (string, string, rabbithole.Policy) {
	fake.putPolicyMutex.RLock()
	defer fake.putPolicyMutex.RUnlock()
	argsForCall := fake.putPolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) PutPolicyReturns(result1 *http.Response, result2 error) {
	fake.putPolicyMutex.Lock()
	defer fake.putPolicyMutex.Unlock()
	fake.PutPolicyStub = nil
	fake.putPolicyReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutPolicyReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putPolicyMutex.Lock()
	defer fake.putPolicyMutex.Unlock()
	fake.PutPolicyStub = nil
	if fake.putPolicyReturnsOnCall == nil {
		fake.putPolicyReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putPolicyReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutUser(arg1 string, arg2 rabbithole.UserSettings) (*http.Response, error) {
	fake.putUserMutex.Lock()
	ret, specificReturn := fake.putUserReturnsOnCall[len(fake.putUserArgsForCall)]
	fake.putUserArgsForCall = append(fake.putUserArgsForCall, struct {
		arg1 string
		arg2 rabbithole.UserSettings
	}{arg1, arg2})
	stub := fake.PutUserStub
	fakeReturns := fake.putUserReturns
	fake.recordInvocation("PutUser", []interface{}{arg1, arg2})
	fake.putUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) PutUserCallCount() int {
	fake.putUserMutex.RLock()
	defer fake.putUserMutex.RUnlock()
	return len(fake.putUserArgsForCall)
}

func (fake *FakeRabbitMQClient) PutUserCalls(stub func(string, rabbithole.UserSettings) (*http.Response, error)) {
	fake.putUserMutex.Lock()
	defer fake.putUserMutex.Unlock()
	fake.PutUserStub = stub
}

func (fake *FakeRabbitMQClient) PutUserArgsForCall(i int) (string, rabbithole.UserSettings) {
	fake.putUserMutex.RLock()
	defer fake.putUserMutex.RUnlock()
	argsForCall := fake.putUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) PutUserReturns(result1 *http.Response, result2 error) {
	fake.putUserMutex.Lock()
	defer fake.putUserMutex.Unlock()
	fake.PutUserStub = nil
	fake.putUserReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutUserReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putUserMutex.Lock()
	defer fake.putUserMutex.Unlock()
	fake.PutUserStub = nil
	if fake.putUserReturnsOnCall == nil {
		fake.putUserReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putUserReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutVhost(arg1 string, arg2 rabbithole.VhostSettings) (*http.Response, error) {
	fake.putVhostMutex.Lock()
	ret, specificReturn := fake.putVhostReturnsOnCall[len(fake.putVhostArgsForCall)]
	fake.putVhostArgsForCall = append(fake.putVhostArgsForCall, struct {
		arg1 string
		arg2 rabbithole.VhostSettings
	}{arg1, arg2})
	stub := fake.PutVhostStub
	fakeReturns := fake.putVhostReturns
	fake.recordInvocation("PutVhost", []interface{}{arg1, arg2})
	fake.putVhostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) PutVhostCallCount() int {
	fake.putVhostMutex.RLock()
	defer fake.putVhostMutex.RUnlock()
	return len(fake.putVhostArgsForCall)
}

func (fake *FakeRabbitMQClient) PutVhostCalls(stub func(string, rabbithole.VhostSettings) (*http.Response, error)) {
	fake.putVhostMutex.Lock()
	defer fake.putVhostMutex.Unlock()
	fake.PutVhostStub = stub
}

func (fake *FakeRabbitMQClient) PutVhostArgsForCall(i int) (string, rabbithole.VhostSettings) {
	fake.putVhostMutex.RLock()
	defer fake.putVhostMutex.RUnlock()
	argsForCall := fake.putVhostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRabbitMQClient) PutVhostReturns(result1 *http.Response, result2 error) {
	fake.putVhostMutex.Lock()
	defer fake.putVhostMutex.Unlock()
	fake.PutVhostStub = nil
	fake.putVhostReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) PutVhostReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.putVhostMutex.Lock()
	defer fake.putVhostMutex.Unlock()
	fake.PutVhostStub = nil
	if fake.putVhostReturnsOnCall == nil {
		fake.putVhostReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.putVhostReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) UpdatePermissionsIn(arg1 string, arg2 string, arg3 rabbithole.Permissions) (*http.Response, error) {
	fake.updatePermissionsInMutex.Lock()
	ret, specificReturn := fake.updatePermissionsInReturnsOnCall[len(fake.updatePermissionsInArgsForCall)]
	fake.updatePermissionsInArgsForCall = append(fake.updatePermissionsInArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 rabbithole.Permissions
	}{arg1, arg2, arg3})
	stub := fake.UpdatePermissionsInStub
	fakeReturns := fake.updatePermissionsInReturns
	fake.recordInvocation("UpdatePermissionsIn", []interface{}{arg1, arg2, arg3})
	fake.updatePermissionsInMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRabbitMQClient) UpdatePermissionsInCallCount() int {
	fake.updatePermissionsInMutex.RLock()
	defer fake.updatePermissionsInMutex.RUnlock()
	return len(fake.updatePermissionsInArgsForCall)
}

func (fake *FakeRabbitMQClient) UpdatePermissionsInCalls(stub func(string, string, rabbithole.Permissions) (*http.Response, error)) {
	fake.updatePermissionsInMutex.Lock()
	defer fake.updatePermissionsInMutex.Unlock()
	fake.UpdatePermissionsInStub = stub
}

func (fake *FakeRabbitMQClient) UpdatePermissionsInArgsForCall(i int) (string, string, rabbithole.Permissions) {
	fake.updatePermissionsInMutex.RLock()
	defer fake.updatePermissionsInMutex.RUnlock()
	argsForCall := fake.updatePermissionsInArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeRabbitMQClient) UpdatePermissionsInReturns(result1 *http.Response, result2 error) {
	fake.updatePermissionsInMutex.Lock()
	defer fake.updatePermissionsInMutex.Unlock()
	fake.UpdatePermissionsInStub = nil
	fake.updatePermissionsInReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) UpdatePermissionsInReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.updatePermissionsInMutex.Lock()
	defer fake.updatePermissionsInMutex.Unlock()
	fake.UpdatePermissionsInStub = nil
	if fake.updatePermissionsInReturnsOnCall == nil {
		fake.updatePermissionsInReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.updatePermissionsInReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeRabbitMQClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clearPermissionsInMutex.RLock()
	defer fake.clearPermissionsInMutex.RUnlock()
	fake.declareBindingMutex.RLock()
	defer fake.declareBindingMutex.RUnlock()
	fake.declareExchangeMutex.RLock()
	defer fake.declareExchangeMutex.RUnlock()
	fake.declareQueueMutex.RLock()
	defer fake.declareQueueMutex.RUnlock()
	fake.declareShovelMutex.RLock()
	defer fake.declareShovelMutex.RUnlock()
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	fake.deleteExchangeMutex.RLock()
	defer fake.deleteExchangeMutex.RUnlock()
	fake.deleteFederationUpstreamMutex.RLock()
	defer fake.deleteFederationUpstreamMutex.RUnlock()
	fake.deleteGlobalParameterMutex.RLock()
	defer fake.deleteGlobalParameterMutex.RUnlock()
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	fake.deleteQueueMutex.RLock()
	defer fake.deleteQueueMutex.RUnlock()
	fake.deleteShovelMutex.RLock()
	defer fake.deleteShovelMutex.RUnlock()
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	fake.deleteVhostMutex.RLock()
	defer fake.deleteVhostMutex.RUnlock()
	fake.listExchangeBindingsBetweenMutex.RLock()
	defer fake.listExchangeBindingsBetweenMutex.RUnlock()
	fake.listQueueBindingsBetweenMutex.RLock()
	defer fake.listQueueBindingsBetweenMutex.RUnlock()
	fake.putFederationUpstreamMutex.RLock()
	defer fake.putFederationUpstreamMutex.RUnlock()
	fake.putGlobalParameterMutex.RLock()
	defer fake.putGlobalParameterMutex.RUnlock()
	fake.putPolicyMutex.RLock()
	defer fake.putPolicyMutex.RUnlock()
	fake.putUserMutex.RLock()
	defer fake.putUserMutex.RUnlock()
	fake.putVhostMutex.RLock()
	defer fake.putVhostMutex.RUnlock()
	fake.updatePermissionsInMutex.RLock()
	defer fake.updatePermissionsInMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRabbitMQClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ internal.RabbitMQClient = new(FakeRabbitMQClient)
